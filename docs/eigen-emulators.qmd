---
output: html_notebook
format:
  html:
    code-fold: show
    code-tools: true
jupyter: python3
---


# Eigen-Emulators {#sec-eigen-emulators}

::: {.hidden}
{{< include macros.qmd >}}
:::


::: {.content-hidden when-format="pdf"}
```{python}
#| echo: false
#| output: false
%load_ext autoreload
%autoreload 2
%matplotlib inline

from IPython.display import display, Markdown
from emulate import jupyter_show_class_method, markdown_class_method
```

```{python}
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C

from emulate import convert_from_r_to_ho_basis
from emulate import leggauss_shifted
from emulate import ho_energy, ho_radial_wf
from emulate import setup_rc_params
from emulate import EigenEmulator, NCSMEmulator, BoundStateOperator

setup_rc_params()
sns.set_palette('pastel')
```
:::

This notebook describes the inner workings of the eigen-emulator and provides examples of its use.

## Theory

For bound states, we can write down the following functional whose stationary solution approximates the energy, that is $\action = \mathcal{E}$, where
$$
\begin{aligned}
    \mathcal{E}[\trial\psi] & = \braket{\trial\psi | H | \trial\psi} - \subspace{E} (\braket{\trial\psi | \trial\psi} - 1).
\end{aligned}
$$
and the normalization of the wave function has been imposed with a Lagrange multiplier $\subspace{E}$.
Imposing stationarity yields
$$
\begin{aligned}
    \delta\mathcal{E}[\trial\psi] & = 0 = 2\braket{\delta\trial\psi | [H-\subspace{E}] | \trial\psi} - \delta\subspace{E} [{\braket{\trial\psi | \trial\psi}} - 1]
\end{aligned}
$$
If $\ket{\trial\psi} = X\coeffs$ then we obtain two relationships from the above constraints
$$
\begin{aligned}
    \subspace{H}\coeffs & = \subspace{E}\subspace{N} \coeffs \\
    \coeffs^\dagger \subspace{N} \coeffs & = 1
\end{aligned}
$$
where $\subspace{H} \equiv X^\dagger H X$ and $\subspace{N} \equiv X^\dagger X$.
The meaning of $\subspace{E}$ can be understood by substituting these relationships back into the variational form:
$$
\begin{aligned}
    \mathcal{E}[\trial\psi] = \subspace{E} \coeffs^\dagger \subspace N \coeffs = \subspace{E}
\end{aligned}
$$
Thus $\subspace{E}$ is an approximation to the energy.


::: {.content-hidden when-format="pdf"}


## The example problem {#sec-perturbed-oscillator-example}

Let's focus on a simple example of a perturbed Harmonic oscillator potential.



```{python}
ell = 0     # Partial wave
n_max = 10  # Oscillator basis size
mass = 1    # mass
b = 1       # Oscillator parameter
# Gaussian quadrature points
r, dr = leggauss_shifted(100, 0, 10)
# Gridded points (for plotting)
r_grid = np.linspace(0, 3, 301)
```



```{python}
osc_wfs = [ho_radial_wf(r_grid, n=i+1, ell=ell, b=b) for i in range(n_max+1)]
osc_wfs = np.stack(osc_wfs, axis=-1)

# Make Gaussian perturbations to the oscillator
H1_params = [0.5, 2, 4]
H1_r_grid = np.stack([np.exp(-(r_grid/a)**2) for a in H1_params], axis=-1)
H1_r = np.stack([np.exp(-(r/a)**2) for a in H1_params], axis=-1)

# Constant term: expected shape = (N_ho_basis, N_ho_basis)
H0 = np.diag([ho_energy(n, ell, omega=1) for n in range(1, n_max+2)])
# Linear term: expected shape = (N_ho_basis, N_ho_basis, n_parameters)
H1 = np.stack([
    convert_from_r_to_ho_basis(H1_r_i, n_max=n_max, ell=ell, r=r, dr=dr, b=b)
    for H1_r_i in H1_r.T
], axis=-1)

R = convert_from_r_to_ho_basis(r, n_max=n_max, ell=ell, r=r, dr=dr, b=b)
```

```{python}
emulator = EigenEmulator('Osc w/Gaussian Perturbation', H0, H1)
```


```{python}
def oscillator_potential(r, mass, omega):
    return 0.5 * mass * (omega * r) ** 2
```

Note that this just stores the large matrices `H0` and `H1` for later processing. You can examine the simple initialization code of the `EigenEmulator` class below:
```{python}
#| echo: false
#| output: true
jupyter_show_class_method(EigenEmulator, '__init__')
```

## Choosing training locations

The first step in constructing the emulator is to choose possible locations where the "snapshots" can be taken.
For now, we will just fill the space using a random design. More optimal methods will be discussed later on.


```{python}
rng = np.random.default_rng(1)
p_train = rng.uniform(-5, 5, size=(6, H1.shape[-1]))
p_valid = rng.uniform(-5, 5, size=(50, H1.shape[-1]))
print(p_train)
```

## Taking snapshots & projecting into the subspace

Next we begin to project the large operators `H0` and `H1` into the subspace spanned by `p_train`. It is as simple as calling `fit` on our `EigenEmulator` object.

```{python}
emulator.fit(p_train)
```

The code straightforwardly follows Eqs.~(xx) and (yy) in the review article, as seen below:
```{python}
#| echo: false
#| output: asis
#| code-fold: true
jupyter_show_class_method(EigenEmulator, 'fit')
```


## Results


```{python}
E_pred = np.stack([emulator.predict(p_i, use_emulator=True) for p_i in p_valid])
E_full = np.stack([emulator.predict(p_i, use_emulator=False) for p_i in p_valid])

wf_train = osc_wfs @ emulator.X
```


```{python}
#| label: fig-harm-osc
#| fig-cap: "A perturbed harmonic oscillator potential and its ground state wave function for various parameter values."
#| code-summary: Code to plot the potential and wave functions
#| code-fold: true

fig, axes = plt.subplots(len(p_train)//2, 2+(len(p_train)%2), figsize=(4, 3.5), sharey=True, sharex=True)

V0 = oscillator_potential(r_grid, mass=mass, omega=1)
for i, p_i in enumerate(p_train):
    ax = axes.ravel()[i]
    ax.plot(r_grid, wf_train[:, i]+emulator.E_train[i], label=r'$u_0(r)$')
    ax.axhline(0, 0, 1, c='lightgrey', lw=0.8, zorder=0)
    V = V0 + H1_r_grid @ p_i
    ax.plot(r_grid, V, c='k', lw=1, label=r"$V(\vec{a})$")
    ax.text(
        0.94, 0.11, fr"$\vec{{a}}_{{{i}}}$",
        transform=ax.transAxes, ha='right', va='bottom',
        bbox=dict(facecolor='w', boxstyle='round'),
    )
axes[0, -1].legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
for ax in axes[-1]:
    ax.set_xlabel(r"$r$")
    ax.set_xticks([0, 1, 2, 3])
ax.set_ylim(-6, 6)
fig.suptitle("Wave Functions in Oscillator + Gaussian Perturbed Potential")
plt.show()
```


See @fig-harm-osc for a visual, or @sec-perturbed-oscillator-example.


```{python}
from emulate.graphs import PRED_KWARGS, BASIS_KWARGS, FULL_KWARGS
```


```{python}
fig, ax = plt.subplots(figsize=(4, 2))
ax.plot(r_grid, wf_train[:, 0], label='Train', **BASIS_KWARGS)
ax.plot(r_grid, wf_train, **BASIS_KWARGS)
for i in range(3):
    if i == 0:
        label_full = 'Exact'
        label_pred = 'Emulated'
    else:
        label_full = label_pred = None
    ax.plot(r_grid, osc_wfs @ emulator.exact_wave_function(p_valid[i]), label=label_full, **FULL_KWARGS)
    ax.plot(r_grid, osc_wfs @ emulator.emulate_wave_function(p_valid[i]), label=label_pred, **PRED_KWARGS)
ax.set_xlabel(r"$r$")
ax.set_ylabel(r"$u_0(r)$")
ax.set_title("Emulated Radial Wave Functions")
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
# fig.savefig("perturbed_oscillator_efficient.png")
```


```{python}
ncsm = NCSMEmulator('NCSM', H0=H0, H1=H1)
ncsm.fit(len(p_train))
E_pred_ncsm = np.stack([ncsm.predict(p_i, use_emulator=True) for p_i in p_valid])
```




```{python}
fig, ax = plt.subplots(figsize=(4, 2))
ax.plot(r_grid, osc_wfs[:, 0], label='Train', **BASIS_KWARGS)
ax.plot(r_grid, osc_wfs, **BASIS_KWARGS)
for i in range(3):
    if i == 0:
        label_full = 'Exact'
        label_pred = 'Emulated'
    else:
        label_full = label_pred = None
    ax.plot(r_grid, osc_wfs @ ncsm.exact_wave_function(p_valid[i]), label=label_full, **FULL_KWARGS)
    ax.plot(r_grid, osc_wfs @ ncsm.emulate_wave_function(p_valid[i]), label=label_pred, **PRED_KWARGS)
ax.set_xlabel(r"$r$")
ax.set_ylabel(r"$u_0(r)$")
ax.set_title("Emulated Radial Wave Functions (NCSM)")
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
# fig.savefig("perturbed_oscillator_ncsm.png")
```



```{python}
fig, ax = plt.subplots(figsize=(4, 2))
for i in range(3):
    ax.plot(
        r_grid,
        osc_wfs @ (ncsm.exact_wave_function(p_valid[i])-ncsm.emulate_wave_function(p_valid[i])),
        ls='-', label='NCSM' if i == 0 else None
    )
    ax.plot(
        r_grid,
        osc_wfs @ (emulator.exact_wave_function(p_valid[i])-emulator.emulate_wave_function(p_valid[i])),
        ls='--', label='Efficient' if i == 0 else None
    )
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
ax.set_xlabel(r"$r$")
ax.set_title("Wave Function Residuals")
ax.axhline(0, 0, 1, c='lightgrey', lw=0.8, zorder=0)
# fig.savefig("perturbed_oscillator_ground_state_wave_function_residuals.png")
```


```{python}
fig, ax = plt.subplots(figsize=(4, 2))
for i in range(3):
    ax.semilogy(
        r_grid,
        np.abs(osc_wfs @ (emulator.exact_wave_function(p_valid[i])-emulator.emulate_wave_function(p_valid[i]))),
        ls='-', label='Efficient' if i == 0 else None
    )
    ax.semilogy(
        r_grid,
        np.abs(osc_wfs @ (ncsm.exact_wave_function(p_valid[i])-ncsm.emulate_wave_function(p_valid[i]))),
        ls='--', label='NCSM' if i == 0 else None
    )
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
ax.set_xlabel(r"$r$")
# ax.set_title("Wave Function Absolute Residuals")
```



```{python}
kernel = C(1) * RBF(length_scale=[1,1,1])
gp = GaussianProcessRegressor(kernel=kernel)
gp.fit(p_train, emulator.E_train)
E_pred_gp, E_std_gp = gp.predict(p_valid, return_std=True)
```


```{python}
fig, ax = plt.subplots(figsize=(4, 2))
ax.semilogy(np.arange(len(E_full)), np.abs(E_pred_gp-E_full), label='GP', ls='-.')
ax.semilogy((E_pred_ncsm-E_full), label='NCSM', ls='--')
ax.semilogy((E_pred-E_full), label='Efficient', ls='--')
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
ax.set_title("Ground-State Energy Residuals")
ax.set_xlabel("Validation Index")
```




## Uncertainty quantification

```{python}
n_valid_1d = 100
p0_valid_1d = np.linspace(-1, 1, n_valid_1d)
p_valid_1d = np.stack([p0_valid_1d, 4.5*np.ones(n_valid_1d), -3.55 * np.ones(n_valid_1d)], axis=-1)
```

```{python}
E_valid_1d_true = np.array([emulator.predict(p, use_emulator=False) for p in p_valid_1d])
E_valid_1d_pred = np.array([emulator.predict(p, use_emulator=True) for p in p_valid_1d])

psi_valid_1d_true = np.array([emulator.exact_wave_function(p) for p in p_valid_1d])
psi_valid_1d_pred = np.array([emulator.emulate_wave_function(p) for p in p_valid_1d])

abs_residual_1d = np.abs(E_valid_1d_pred - E_valid_1d_true)
psi_residual_1d = np.linalg.norm(psi_valid_1d_pred - psi_valid_1d_true, axis=-1)
stdv_psi_valid_1d = np.sqrt(np.array([emulator.variance_expensive(p) for p in p_valid_1d]))
stdv_E_valid_1d = stdv_psi_valid_1d ** 2
```

```{python}
fig, axes = plt.subplots(2, 1, figsize=(3.5, 4), sharex=True)

ax = axes[0]
ax.plot(p0_valid_1d, psi_residual_1d, label=r"$||\,|{\Delta\psi}\rangle\,||$", **FULL_KWARGS)
ax.plot(p0_valid_1d, stdv_psi_valid_1d * np.average(psi_residual_1d/stdv_psi_valid_1d), label="Error Emulator", **PRED_KWARGS)
ax.legend()
ax.set_title("Bound State Error Emulator")

ax = axes[1]
ax.plot(p0_valid_1d, abs_residual_1d, label=r"$|\Delta E|$", **FULL_KWARGS)
ax.plot(p0_valid_1d, stdv_E_valid_1d * np.average(abs_residual_1d/stdv_E_valid_1d), label="Error Emulator", **PRED_KWARGS)
ax.set_xlabel("$a_0$ Parameter Value")
ax.legend()
# fig.savefig("bound_state_error_emulator.png")
```





## Operators


```{python}
op = BoundStateOperator(name='R', ham=emulator, op0=R)
op_ncsm = BoundStateOperator(name='R', ham=ncsm, op0=R)
```



```{python}
R_full = np.stack([op.predict(p_i, use_emulator=False) for p_i in p_valid])
R_pred = np.stack([op.predict(p_i, use_emulator=True) for p_i in p_valid])

R_pred_ncsm = np.stack([op_ncsm.predict(p_i, use_emulator=True) for p_i in p_valid])
```


```{python}
kernel = C(1) * RBF(length_scale=[1, 1, 1])
gp_op = GaussianProcessRegressor(kernel=kernel)
gp_op.fit(p_train, np.stack([op.predict(p_i, use_emulator=False) for p_i in p_train]))
R_pred_gp, R_std_gp = gp_op.predict(p_valid, return_std=True)
```



```{python}
fig, ax = plt.subplots(figsize=(4, 2))
ax.semilogy(np.arange(len(R_full)), np.abs(R_pred_gp-R_full), label='GP', ls='-.')
ax.semilogy(np.abs(R_pred_ncsm-R_full), label='NCSM', ls='--')
ax.semilogy(np.abs(R_pred-R_full), label='Efficient')
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
ax.set_title("Ground-State Radius Residuals")
ax.set_xlabel("Validation Index")
# fig.savefig("perturbed_oscillator_ground_state_radius_residuals.png")
```


:::