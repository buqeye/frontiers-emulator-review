---
output: html_notebook
format:
  html:
    code-fold: show
    code-tools: true
jupyter: python3
---


# Eigen-Emulators {#sec-eigen-emulators}

::: {.hidden}
{{< include macros.qmd >}}
:::


{{< include _code_preamble.qmd >}}


::: {.content-hidden when-format="pdf"}
```{python}
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C

from emulate import convert_from_r_to_ho_basis
from emulate import leggauss_shifted
from emulate import ho_energy, ho_radial_wf
from emulate import setup_rc_params
from emulate import EigenEmulator, OscillatorEmulator, BoundStateOperator

setup_rc_params()
sns.set_palette('pastel')
```
:::


<!-- ```{python}
print(plt.rcParams['savefig.dpi'])
print(plt.rcParams['figure.dpi'])
print(plt.rcParams['figure.figsize'])
print(plt.rcParams["figure.constrained_layout.use"])
print(plt.rcParams["figure.constrained_layout.h_pad"])
print(plt.rcParams["figure.constrained_layout.w_pad"])
print(plt.rcParams["savefig.pad_inches"])
print(plt.rcParams["savefig.bbox"])
``` -->

![Model reduction](./test_fig/tex/test_fig.png){fig.pos="tb" fig-env="figure*"}


This notebook describes the inner workings of the eigen-emulator and provides examples of its use.

## Theory

For bound states, we can write down the following functional whose stationary solution approximates the energy, that is $\action = \mathcal{E}$, where
$$
\begin{aligned}
    \mathcal{E}[\trial\psi] & = \braket{\trial\psi | H | \trial\psi} - \subspace{E} (\braket{\trial\psi | \trial\psi} - 1).
\end{aligned}
$$
and the normalization of the wave function has been imposed with a Lagrange multiplier $\subspace{E}$.
Imposing stationarity yields
$$
\begin{aligned}
    \delta\mathcal{E}[\trial\psi] & = 0 = 2\braket{\delta\trial\psi | [H-\subspace{E}] | \trial\psi} - \delta\subspace{E} [{\braket{\trial\psi | \trial\psi}} - 1]
\end{aligned}
$$
If $\ket{\trial\psi} = X\coeffs$ then we obtain two relationships from the above constraints
$$
\begin{aligned}
    \subspace{H}\coeffs & = \subspace{E}\subspace{N} \coeffs \\
    \coeffs^\dagger \subspace{N} \coeffs & = 1
\end{aligned}
$$
where $\subspace{H} \equiv X^\dagger H X$ and $\subspace{N} \equiv X^\dagger X$.
The meaning of $\subspace{E}$ can be understood by substituting these relationships back into the variational form:
$$
\begin{aligned}
    \mathcal{E}[\trial\psi] = \subspace{E} \coeffs^\dagger \subspace N \coeffs = \subspace{E}
\end{aligned}
$$
Thus $\subspace{E}$ is an approximation to the energy.


See @fig-harm-osc for a visual, or @sec-perturbed-oscillator-example.

::: {.content-hidden when-format="pdf"}


## The example problem {#sec-perturbed-oscillator-example}

Let's focus on a simple example of a perturbed Harmonic oscillator potential.



```{python}
ell = 0     # Partial wave
n_max = 10  # Oscillator basis size
mass = 1    # mass
b = 1       # Oscillator parameter
# Gaussian quadrature points
r, dr = leggauss_shifted(100, 0, 10)
# Gridded points (for plotting)
r_grid = np.linspace(0, 3, 301)
n_train = 6
```



```{python}
osc_wfs = [ho_radial_wf(r_grid, n=i+1, ell=ell, b=b) for i in range(n_max+1)]
osc_wfs = np.stack(osc_wfs, axis=-1)

# Make Gaussian perturbations to the oscillator
H1_params = [0.5, 2, 4]
H1_r_grid = np.stack([np.exp(-(r_grid/a)**2) for a in H1_params], axis=-1)
H1_r = np.stack([np.exp(-(r/a)**2) for a in H1_params], axis=-1)

# Constant term: expected shape = (N_ho_basis, N_ho_basis)
H0 = np.diag([ho_energy(n, ell, omega=1) for n in range(1, n_max+2)])
# Linear term: expected shape = (N_ho_basis, N_ho_basis, n_parameters)
H1 = np.stack([
    convert_from_r_to_ho_basis(H1_r_i, n_max=n_max, ell=ell, r=r, dr=dr, b=b)
    for H1_r_i in H1_r.T
], axis=-1)

R = convert_from_r_to_ho_basis(r, n_max=n_max, ell=ell, r=r, dr=dr, b=b)
```

```{python}
emulator = EigenEmulator('Osc w/Gaussian Perturbation', H0, H1)
```


```{python}
def oscillator_potential(r, mass, omega):
    return 0.5 * mass * (omega * r) ** 2
```

Note that this just stores the large matrices `H0` and `H1` for later processing. You can examine the simple initialization code of the `EigenEmulator` class below:
```{python}
#| echo: false
#| output: true
jupyter_show_class_method(EigenEmulator, '__init__')
```

## Choosing training locations

The first step in constructing the emulator is to choose possible locations where the "snapshots" can be taken.
For now, we will just fill the space using a random design. More optimal methods will be discussed later on.


```{python}
rng = np.random.default_rng(1)
p_train = rng.uniform(-5, 5, size=(n_train, H1.shape[-1]))
p_valid = rng.uniform(-5, 5, size=(50, H1.shape[-1]))
print(p_train)
```

## Taking snapshots & projecting into the subspace

Next we begin to project the large operators `H0` and `H1` into the subspace spanned by `p_train`. It is as simple as calling `fit` on our `EigenEmulator` object.

```{python}
emulator.fit(p_train)
```

The code straightforwardly follows Eqs.~(xx) and (yy) in the review article, as seen below:
```{python}
#| echo: false
#| output: asis
#| code-fold: true
jupyter_show_class_method(EigenEmulator, 'fit')
```


## Results


```{python}
E_pred = np.stack([emulator.predict(p_i, use_emulator=True) for p_i in p_valid])
E_full = np.stack([emulator.predict(p_i, use_emulator=False) for p_i in p_valid])

wf_train = osc_wfs @ emulator.X
```

```{python}
#| code-summary: Code to plot the potential and wave functions
#| code-fold: true
#| output: false

fig, axes = plt.subplots(
    len(p_train)//2, 2+(len(p_train)%2), figsize=(3.3, 3),
    sharey=True, sharex=True,
    layout="tight",
)

V0 = oscillator_potential(r_grid, mass=mass, omega=1)
for i, p_i in enumerate(p_train):
    ax = axes.ravel()[i]
    psi_line, = ax.plot(r_grid, wf_train[:, i]+emulator.E_train[i], label=r'$\psi(r)$')
    ax.axhline(0, 0, 1, c='lightgrey', lw=0.8, zorder=0)
    V = V0 + H1_r_grid @ p_i
    pot_line, = ax.plot(r_grid, V, c='k', lw=0.8, label=r"$V(\boldsymbol{\theta})$")
    ax.text(
        0.93, 0.12, fr"$\boldsymbol{{\theta}}_{{{i}}}$",
        transform=ax.transAxes, ha='right', va='bottom',
        bbox=dict(facecolor='w', boxstyle='round'),
    )
# axes[0, -1].legend(loc='upper left', bbox_to_anchor=(1.03, 1), borderaxespad=0)
# axes[0, 0].legend(loc='lower left', bbox_to_anchor=(0, 1.03), ncol=2, borderaxespad=0)
# axes[0, 0].legend((psi_line,), (r'$\psi(r)$',), loc='lower left', bbox_to_anchor=(0, 1.03), ncol=2, borderaxespad=0)
axes[0, 0].legend(loc='lower left', bbox_to_anchor=(0, 1.05, 1, 1), ncol=2, borderaxespad=0, columnspacing=0.3, mode="expand")
# fig.legend(
#     (psi_line, pot_line), (r'$\psi(r)$', r"$V(\boldsymbol{\theta})$"),
#     loc='lower left', bbox_to_anchor=(0, 1.03), ncol=2, borderaxespad=0,
#     bbox_transform=axes[0, 0].transAxes, framealpha=1,
# )
for ax in axes[-1]:
    ax.set_xlabel(r"Radius $r$ [fm]")
    ax.set_xticks([0, 1, 2, 3])
ax.set_ylim(-6, 6)
# fig.tight_layout(w_pad=1.5 / 72, h_pad=1.5 / 72)
# fig.suptitle("Wave Functions in a Perturbed Oscillator Potential")
```
::: 

```{python}
#| label: fig-harm-osc
#| fig-cap: "A perturbed harmonic oscillator potential and its ground state wave function for various parameter values."
#| echo: false
# with mpl.rc_context({'figure.constrained_layout.use': False}):
with mpl.rc_context({'figure.constrained_layout.use': True, "figure.constrained_layout.h_pad": 1.5 / 72, "figure.constrained_layout.w_pad": 1.5 / 72}):
    plt.show()
```




See @fig-harm-osc for a visual, or @sec-perturbed-oscillator-example.


::: {.content-hidden when-format="pdf"}


```{python}
from emulate.graphs import PRED_KWARGS, BASIS_KWARGS, FULL_KWARGS
```

```{python}
ncsm = OscillatorEmulator('NCSM', H0=H0, H1=H1)
ncsm.fit(len(p_train))
E_pred_ncsm = np.stack([ncsm.predict(p_i, use_emulator=True) for p_i in p_valid])
```



```{python}
#| code-summary: Code to plot the RBM emulator wave functions
#| code-fold: true
#| output: false
fig, axes = plt.subplots(2, 1, figsize=(3.3, 3), sharex=False)

ax = axes.ravel()[0]

n_example = 3
ax.plot(r_grid, wf_train[:, 0], label='Basis', **BASIS_KWARGS)
ax.plot(r_grid, wf_train, **BASIS_KWARGS)
label_full = 'Exact'
for i in range(n_example):
    ax.plot(r_grid, osc_wfs @ emulator.exact_wave_function(p_valid[i]), label=label_full, **FULL_KWARGS)
    if i == 0:
        label_pred = 'Emulator'
        ax.plot(r_grid, osc_wfs @ emulator.emulate_wave_function(p_valid[i]),   label=label_pred, c='w', **PRED_KWARGS)
    ax.plot(r_grid, osc_wfs @ emulator.emulate_wave_function(p_valid[i]), **PRED_KWARGS)
    label_full = None
# ax.set_xlabel(r"$r$")
# ax.set_ylabel(r"$\psi(r)$ (RBM)")
ax.set_ylabel(r"$\psi(r)$")
ax.set_yticks([])
ax.set_xticks([])
ax.axhline(0, 0, 1, c='k', lw=0.8, zorder=0)
# ax.set_title("RBM Emulated Radial Wave Functions")
ax.legend(loc='lower left', bbox_to_anchor=(0, 1.03, 1, 1), ncol=3, borderaxespad=0, mode="expand")
ax.spines.right.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.bottom.set_visible(False)
# ax.spines.top.set_visible(False)
ax.text(0.95, 0.95, "RBM", ha="right", va="top", bbox=dict(boxstyle="round", fc="w"), transform=ax.transAxes)


# fig, ax = plt.subplots(figsize=(4, 2))
ax = axes.ravel()[1]
ax.plot(r_grid, osc_wfs[:, 0], **BASIS_KWARGS)
ax.plot(r_grid, osc_wfs, **BASIS_KWARGS)
for i in range(n_example):
    ax.plot(r_grid, osc_wfs @ ncsm.exact_wave_function(p_valid[i]), label=label_full, **FULL_KWARGS)
    ax.plot(r_grid, osc_wfs @ ncsm.emulate_wave_function(p_valid[i]), label=label_pred, **PRED_KWARGS)
ax.set_xlabel(r"$r$")
# ax.set_ylabel(r"$\psi(r)$ (NCSM)")
ax.set_ylabel(r"$\psi(r)$")
ax.set_yticks([])
ax.set_xticks([0, 1, 2, 3])
ax.axhline(0, 0, 1, c='k', lw=0.8, zorder=0)
ax.spines.right.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.bottom.set_position(('outward', 5))
ax.spines.bottom.set_bounds((0, 3))
ax.text(0.95, 0.95, "HO", ha="right", va="top", bbox=dict(boxstyle="round", fc="w"), transform=ax.transAxes)
# ax.set_title("Emulated Radial Wave Functions (NCSM)")
# ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)

```
::: 

```{python}
#| label: fig-eigen-emulator-wavefunctions
#| fig-cap: "Wave functions constructed via a RBM-based eigen-emulator"
#| echo: false
plt.show()
```

```{python}
import ipywidgets as widgets
from IPython.display import display

w = widgets.IntSlider()
display(w)
```



::: {.content-hidden when-format="pdf"}




<!--
```{python}
fig, ax = plt.subplots(figsize=(4, 2))
ax.plot(r_grid, osc_wfs[:, 0], label='Train', **BASIS_KWARGS)
ax.plot(r_grid, osc_wfs, **BASIS_KWARGS)
for i in range(n_example):
    if i == 0:
        label_full = 'Exact'
        label_pred = 'Emulated'
    else:
        label_full = label_pred = None
    ax.plot(r_grid, osc_wfs @ ncsm.exact_wave_function(p_valid[i]), label=label_full, **FULL_KWARGS)
    ax.plot(r_grid, osc_wfs @ ncsm.emulate_wave_function(p_valid[i]), label=label_pred, **PRED_KWARGS)
ax.set_xlabel(r"$r$")
ax.set_ylabel(r"$u_0(r)$")
ax.set_title("Emulated Radial Wave Functions (NCSM)")
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
plt.show()
```
-->


<!--
```{python}
fig, ax = plt.subplots(figsize=(4, 2))
for i in range(n_example):
    ax.plot(
        r_grid,
        osc_wfs @ (ncsm.exact_wave_function(p_valid[i])-ncsm.emulate_wave_function(p_valid[i])),
        ls='-', label='NCSM' if i == 0 else None
    )
    ax.plot(
        r_grid,
        osc_wfs @ (emulator.exact_wave_function(p_valid[i])-emulator.emulate_wave_function(p_valid[i])),
        ls='--', label='Efficient' if i == 0 else None
    )
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
ax.set_xlabel(r"$r$")
ax.set_title("Wave Function Residuals")
ax.axhline(0, 0, 1, c='lightgrey', lw=0.8, zorder=0)
plt.show()
```
-->


```{python}
#| label: fig-wave-function-residuals
#| fig-cap: "Absolute residuals between each emulator and the exact wave function calculation"
#| echo: false
fig, ax = plt.subplots(figsize=(3.3, 2.5))
for i in range(n_example):
    ax.semilogy(
        r_grid,
        np.abs(osc_wfs @ (ncsm.exact_wave_function(p_valid[i])-ncsm.emulate_wave_function(p_valid[i]))),
        ls='--', label="HO" if i == 0 else None
    )
    ax.semilogy(
        r_grid,
        np.abs(osc_wfs @ (emulator.exact_wave_function(p_valid[i])-emulator.emulate_wave_function(p_valid[i]))),
        ls='-', label='RBM' if i == 0 else None
    )
# ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
ax.legend()
ax.set_xlabel(r"$r$")
ax.set_title("Wave Function Absolute Residuals")
plt.show()
```



```{python}
kernel = C(1) * RBF(length_scale=[1, 1, 1])
gp = GaussianProcessRegressor(kernel=kernel)
gp.fit(p_train, emulator.E_train)
E_pred_gp, E_std_gp = gp.predict(p_valid, return_std=True)
```


```{python}
#| label: fig-energy-residuals
#| fig-cap: "Absolute residuals between each emulator and the exact energy calculation"
#| echo: false
fig, ax = plt.subplots(figsize=(3.3, 2))
ax.semilogy(np.arange(len(E_full)), np.abs(E_pred_gp-E_full), label='GP', ls=':')
ax.semilogy((E_pred_ncsm-E_full), label="HO", ls='--')
ax.semilogy((E_pred-E_full), label='RBM', ls='-')
ax.legend(loc='upper left', bbox_to_anchor=(1.03, 1), borderaxespad=0)
ax.set_title("Ground-State Energy Residuals")
ax.set_xlabel("Validation Index")
plt.show()
```




## Uncertainty quantification

```{python}
n_valid_1d = 100
p0_valid_1d = np.linspace(-1, 1, n_valid_1d)
p_valid_1d = np.stack([p0_valid_1d, 4.5*np.ones(n_valid_1d), -3.55 * np.ones(n_valid_1d)], axis=-1)
```

```{python}
E_valid_1d_true = np.array([emulator.predict(p, use_emulator=False) for p in p_valid_1d])
E_valid_1d_pred = np.array([emulator.predict(p, use_emulator=True) for p in p_valid_1d])

psi_valid_1d_true = np.array([emulator.exact_wave_function(p) for p in p_valid_1d])
psi_valid_1d_pred = np.array([emulator.emulate_wave_function(p) for p in p_valid_1d])

abs_residual_1d = np.abs(E_valid_1d_pred - E_valid_1d_true)
psi_residual_1d = np.linalg.norm(psi_valid_1d_pred - psi_valid_1d_true, axis=-1)
stdv_psi_valid_1d = np.sqrt(np.array([emulator.variance_expensive(p) for p in p_valid_1d]))
stdv_E_valid_1d = stdv_psi_valid_1d ** 2
```

```{python}
fig, axes = plt.subplots(2, 1, figsize=(3.3, 3.2), sharex=True)

ax = axes[0]
ax.plot(p0_valid_1d, psi_residual_1d, label=r"$||\,|{\Delta\psi}\rangle\,||$", **FULL_KWARGS)
ax.plot(p0_valid_1d, stdv_psi_valid_1d * np.average(psi_residual_1d/stdv_psi_valid_1d), label="Error Emulator", **PRED_KWARGS)
ax.legend()
ax.set_title("Bound State Error Emulator")

ax = axes[1]
ax.plot(p0_valid_1d, abs_residual_1d, label=r"$|\Delta E|$", **FULL_KWARGS)
ax.plot(p0_valid_1d, stdv_E_valid_1d * np.average(abs_residual_1d/stdv_E_valid_1d), label="Error Emulator", **PRED_KWARGS)
ax.set_xlabel("$a_0$ Parameter Value")
ax.legend()
plt.show()
```





## Operators


```{python}
op = BoundStateOperator(name='R', ham=emulator, op0=R)
op_ncsm = BoundStateOperator(name='R', ham=ncsm, op0=R)
```



```{python}
R_full = np.stack([op.predict(p_i, use_emulator=False) for p_i in p_valid])
R_pred = np.stack([op.predict(p_i, use_emulator=True) for p_i in p_valid])

R_pred_ncsm = np.stack([op_ncsm.predict(p_i, use_emulator=True) for p_i in p_valid])
```


```{python}
kernel = C(1) * RBF(length_scale=[1, 1, 1])
gp_op = GaussianProcessRegressor(kernel=kernel)
gp_op.fit(p_train, np.stack([op.predict(p_i, use_emulator=False) for p_i in p_train]))
R_pred_gp, R_std_gp = gp_op.predict(p_valid, return_std=True)
```



```{python}
#| label: fig-radius-residuals
#| fig-cap: "Absolute residuals between each emulator and the exact radius calculation"
#| echo: false
fig, ax = plt.subplots(figsize=(3.4, 2))
ax.semilogy(np.arange(len(R_full)), np.abs(R_pred_gp-R_full), label='GP', ls=':')
ax.semilogy(np.abs(R_pred_ncsm-R_full), label="HO", ls='--')
ax.semilogy(np.abs(R_pred-R_full), label='RBM')
ax.legend(loc='upper left', bbox_to_anchor=(1.03,1), borderaxespad=0)
ax.set_title("Ground-State Radius Residuals")
ax.set_xlabel("Validation Index")
plt.show()
```


:::